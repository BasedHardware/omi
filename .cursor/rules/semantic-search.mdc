---
description: "Effective use of semantic search for code discovery and understanding"
alwaysApply: false
references:
  - https://cursor.com/docs/context/semantic-search
---

# Semantic Search

Semantic search finds code by understanding its meaning, not just matching text. Use natural language questions to discover relevant code across your entire codebase.

## How Semantic Search Works

Semantic search uses a 7-step process:

1. **Workspace sync**: Files securely synchronized with Cursor's servers
2. **Chunking**: Files broken into meaningful chunks (functions, classes, logical blocks)
3. **Embeddings**: Each chunk converted to vector representation using AI models
4. **Storage**: Embeddings stored in specialized vector database
5. **Query embedding**: Your search query converted to vector
6. **Similarity search**: System finds most similar code chunks
7. **Results**: Relevant code snippets ranked by semantic similarity

## Why Use Semantic Search

**Benefits over grep:**
- **Faster results**: Compute happens during indexing (offline)
- **Better accuracy**: Custom-trained models retrieve more relevant results
- **Fewer follow-ups**: Users send fewer clarifying messages
- **Conceptual matching**: Find code by what it does, not just what it's named

**Example:**
- Searching for "top navigation" finds `header.tsx` even though "navigation" doesn't appear in filename
- Searching for "user authentication" finds login, signin, auth functions

## When to Use Semantic vs Grep

**Use Semantic Search for:**
- Finding code by functionality or purpose
- Discovering related code across the codebase
- Understanding how a feature is implemented
- Finding similar patterns or implementations
- Exploring unfamiliar codebase areas

**Use Grep for:**
- Exact string matches (function names, variable names)
- Finding specific imports or references
- Locating exact error messages
- Finding specific file patterns

**Best Practice**: Agent uses **both** semantic search and grep together for best results.

## Effective Search Strategies

### Natural Language Queries

**Good queries:**
- "How does authentication work?"
- "Where is memory extraction handled?"
- "How are WebSocket connections managed?"
- "Where do we handle BLE device pairing?"

**Avoid:**
- Overly vague: "code"
- Too specific: "function named get_user"
- Multiple unrelated concepts in one query

### Query Refinement

**Start broad, then narrow:**
1. "How does conversation processing work?"
2. "Show me the memory extraction flow"
3. "Where is the LLM prompt for memory extraction?"

**Build understanding incrementally:**
- Each query builds on previous results
- Use follow-up questions to dive deeper
- Combine multiple searches for comprehensive understanding

### Search Patterns for Omi

**Backend searches:**
- "How are conversations processed?"
- "Where is memory extraction implemented?"
- "How does the chat system route requests?"
- "Where are API endpoints defined?"

**Flutter searches:**
- "How does BLE device connection work?"
- "Where is audio streaming handled?"
- "How is state managed in the app?"

**Firmware searches:**
- "How are BLE services implemented?"
- "Where is audio codec handling?"

## Semantic Search Best Practices

### For Developers

1. **Use natural language**: Ask questions as you would ask a colleague
2. **Be specific about context**: "authentication in backend" vs just "authentication"
3. **Combine with grep**: Use semantic search for discovery, grep for exact matches
4. **Review results**: Check multiple results to understand full picture
5. **Follow references**: Use search results to find related code

### For Agents

1. **Use semantic search first**: For understanding codebase structure
2. **Use grep for exact matches**: When you know what you're looking for
3. **Combine approaches**: Semantic for discovery, grep for verification
4. **Search incrementally**: Start broad, narrow based on results
5. **Reference search results**: Use found code as examples

## Omi-Specific Search Patterns

### Backend Patterns

**Conversation Processing:**
- "How are conversations processed from WebSocket to storage?"
- "Where is transcript processing handled?"

**Memory Extraction:**
- "How are memories extracted from conversations?"
- "Where is memory conflict resolution?"

**Chat System:**
- "How does the LangGraph chat router work?"
- "Where are chat tools defined?"

### Flutter Patterns

**BLE Communication:**
- "How does the app connect to BLE devices?"
- "Where is audio streaming handled?"

**State Management:**
- "How is app state managed with Provider?"
- "Where are user preferences stored?"

### Integration Patterns

**API Integration:**
- "How do plugins integrate with the backend?"
- "Where are webhooks handled?"

## Indexing and Performance

**Automatic indexing:**
- Indexing begins when you open workspace
- Semantic search available at 80% completion
- Updates automatically every 5 minutes
- Only changed files are re-indexed

**What gets indexed:**
- All files except those in `.cursorignore` or `.gitignore`
- Large/complex files may be skipped for performance

**View indexed files:**
- `Cursor Settings` → `Indexing & Docs` → `View included files`

## Privacy and Security

- File paths encrypted before sending
- Code content never stored in plaintext
- Code only held in memory during indexing
- No permanent storage of source code

## Related Resources

### Rules
- `.cursor/rules/codebase-overview.mdc` - System architecture
- `.cursor/rules/context-management.mdc` - Context optimization

### Commands
- `/semantic-search` - Semantic search guidance

### Skills
- `.cursor/skills/context-optimization/` - Context management

### Documentation
- [Cursor Semantic Search Docs](https://cursor.com/docs/context/semantic-search)