---
description: "Firmware C C++ nRF ESP32 Zephyr RTOS Arduino embedded systems BLE services audio codecs power management"
globs:
  - "omi/**/*.c"
  - "omi/**/*.h"
  - "omiGlass/**/*.c"
  - "omiGlass/**/*.h"
alwaysApply: false
references:
  - docs/doc/developer/firmware/Compile_firmware.mdx
  - docs/doc/developer/Protocol.mdx
---

# Firmware Architecture

## Device Types

### Omi Device
**Location**: `omi/`
**Platform**: nRF chips (nRF52840, nRF5340)
**RTOS**: Zephyr

### Omi Glass
**Location**: `omiGlass/`
**Platform**: ESP32-S3
**Framework**: Arduino/ESP-IDF

## Zephyr RTOS (Omi Device)

### Project Structure

```
omi/firmware/
├── CMakeLists.txt
├── prj.conf
├── overlay.conf
├── src/
│   ├── main.c
│   └── ...
└── boards/
```

### Configuration Files

**prj.conf**: Main configuration
```conf
CONFIG_BT=y
CONFIG_BT_PERIPHERAL=y
CONFIG_BT_GATT_SERVICE=y
```

**overlay.conf**: Board-specific overrides

### BLE Service Definition

```c
// Define service UUID
#define BT_UUID_AUDIO_SERVICE_VAL \
    BT_UUID_128_ENCODE(0x19B10000, 0xE8F2, 0x537E, 0x4F6C, 0xD104768A1214)

// Define characteristic UUIDs
#define BT_UUID_AUDIO_DATA_VAL \
    BT_UUID_128_ENCODE(0x19B10001, 0xE8F2, 0x537E, 0x4F6C, 0xD104768A1214)

#define BT_UUID_CODEC_TYPE_VAL \
    BT_UUID_128_ENCODE(0x19B10002, 0xE8F2, 0x537E, 0x4F6C, 0xD104768A1214)
```

### Audio Packet Structure

```c
typedef struct {
    uint16_t packet_number;  // Little-endian
    uint8_t index;
    uint8_t audio_data[160 * 2];  // 160 samples, 16-bit
} audio_packet_t;

void send_audio_packet(audio_packet_t *packet) {
    uint8_t buffer[3 + sizeof(packet->audio_data)];
    
    // Header
    buffer[0] = packet->packet_number & 0xFF;
    buffer[1] = (packet->packet_number >> 8) & 0xFF;
    buffer[2] = packet->index;
    
    // Audio data
    memcpy(&buffer[3], packet->audio_data, sizeof(packet->audio_data));
    
    // Send via BLE notification
    bt_gatt_notify(conn, &audio_char, buffer, sizeof(buffer));
}
```

## ESP32-S3 (Omi Glass)

### Arduino Framework

```cpp
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>

// Service UUID
#define SERVICE_UUID "19B10000-E8F2-537E-4F6C-D104768A1214"
#define AUDIO_DATA_UUID "19B10001-E8F2-537E-4F6C-D104768A1214"
#define CODEC_TYPE_UUID "19B10002-E8F2-537E-4F6C-D104768A1214"

class AudioCharacteristicCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {
        // Handle audio data write
    }
};

void setup() {
    BLEDevice::init("Omi");
    BLEServer *pServer = BLEDevice::createServer();
    
    BLEService *pService = pServer->createService(SERVICE_UUID);
    
    BLECharacteristic *pAudioChar = pService->createCharacteristic(
        AUDIO_DATA_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    
    pAudioChar->setCallbacks(new AudioCharacteristicCallbacks());
    pService->start();
    
    BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->start();
}
```

## Codec Implementation

### Opus Encoding

```c
#include <opus.h>

OpusEncoder *encoder;
opus_int16 pcm[160];
unsigned char opus_data[40];

void init_opus_encoder() {
    int error;
    encoder = opus_encoder_create(
        16000,  // Sample rate
        1,      // Channels (mono)
        OPUS_APPLICATION_VOIP,
        &error
    );
}

void encode_audio(opus_int16 *pcm_samples, int frame_size) {
    int encoded_bytes = opus_encode(
        encoder,
        pcm_samples,
        frame_size,
        opus_data,
        40
    );
    
    // Send opus_data via BLE
}
```

### PCM Format

```c
// 16-bit PCM, little-endian
void send_pcm_audio(int16_t *samples, int count) {
    uint8_t buffer[count * 2];
    
    for (int i = 0; i < count; i++) {
        buffer[i * 2] = samples[i] & 0xFF;
        buffer[i * 2 + 1] = (samples[i] >> 8) & 0xFF;
    }
    
    // Send via BLE
}
```

## Battery Service

### Implementation

```c
// Standard BLE Battery Service
BT_GATT_SERVICE_DEFINE(battery_svc,
    BT_GATT_PRIMARY_SERVICE(BT_UUID_BAS),
    BT_GATT_CHARACTERISTIC(BT_UUID_BAS_BATTERY_LEVEL,
        BT_GATT_CHRC_READ | BT_GATT_CHRC_NOTIFY,
        BT_GATT_PERM_READ,
        read_battery_level, NULL, NULL),
);

static uint8_t read_battery_level(struct bt_conn *conn,
                                  struct bt_gatt_attr *attr,
                                  void *buf, uint16_t len, uint16_t offset) {
    uint8_t level = get_battery_level();  // 0-100
    return bt_gatt_attr_read(conn, attr, buf, len, offset, &level, 1);
}
```

## Device Information Service

### Implementation

```c
BT_GATT_SERVICE_DEFINE(device_info_svc,
    BT_GATT_PRIMARY_SERVICE(BT_UUID_DIS),
    
    BT_GATT_CHARACTERISTIC(BT_UUID_DIS_MANUFACTURER_NAME,
        BT_GATT_CHRC_READ,
        BT_GATT_PERM_READ,
        read_manufacturer, NULL, NULL),
    
    BT_GATT_CHARACTERISTIC(BT_UUID_DIS_MODEL_NUMBER,
        BT_GATT_CHRC_READ,
        BT_GATT_PERM_READ,
        read_model, NULL, NULL),
    
    BT_GATT_CHARACTERISTIC(BT_UUID_DIS_FIRMWARE_REV,
        BT_GATT_CHRC_READ,
        BT_GATT_PERM_READ,
        read_firmware, NULL, NULL),
);

static uint8_t read_manufacturer(struct bt_conn *conn,
                                 struct bt_gatt_attr *attr,
                                 void *buf, uint16_t len, uint16_t offset) {
    const char *name = "Based Hardware";
    return bt_gatt_attr_read(conn, attr, buf, len, offset, name, strlen(name));
}

static uint8_t read_firmware(struct bt_conn *conn,
                             struct bt_gatt_attr *attr,
                             void *buf, uint16_t len, uint16_t offset) {
    const char *version = "1.0.3";
    return bt_gatt_attr_read(conn, attr, buf, len, offset, version, strlen(version));
}
```

## Best Practices

1. **Memory Management**: Free allocated memory
2. **Error Handling**: Check return values from BLE functions
3. **Packet Fragmentation**: Handle MTU limitations
4. **Power Management**: Optimize for battery life
5. **Codec Selection**: Default to Opus (most efficient)
6. **Version Management**: Update firmware version in DIS
7. **Testing**: Test on actual hardware

## Related Documentation

**The `docs/` folder is the single source of truth for all user-facing documentation, deployed at [docs.omi.me](https://docs.omi.me/).**

- **BLE Protocol**: `docs/doc/developer/Protocol.mdx` - [View online](https://docs.omi.me/doc/developer/Protocol)
- **Firmware Compilation**: `docs/doc/developer/firmware/Compile_firmware.mdx` - [View online](https://docs.omi.me/doc/developer/firmware/Compile_firmware)
- **Hardware Docs**: `docs/doc/hardware/` - [View online](https://docs.omi.me/doc/hardware/)
  - Omi Consumer: `docs/doc/hardware/OmiConsumer.mdx`
  - DevKit 2: `docs/doc/hardware/DevKit2.mdx`
  - DevKit 1: `docs/doc/hardware/DevKit1.mdx`
  - Omi Glass: `docs/doc/hardware/omiGlass.mdx`
- **Build Guide**: `omi/firmware/BUILD_AND_OTA_FLASH.md`

## Related Cursor Resources

### Rules
- `.cursor/rules/firmware-ble-service.mdc` - BLE service implementation
- `.cursor/rules/firmware-audio-codecs.mdc` - Audio codec implementation
- `.cursor/rules/flutter-ble-protocol.mdc` - Flutter BLE integration

### Skills
- `.cursor/skills/omi-firmware-patterns/` - Firmware patterns and workflows

### Subagents
- `.cursor/agents/firmware-engineer/` - Firmware development specialist

### Commands
- `/flutter-setup` - Setup firmware development environment
