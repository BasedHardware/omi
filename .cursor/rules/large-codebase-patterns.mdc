---
description: "Best practices for working with large codebases in Cursor"
alwaysApply: false
references:
  - https://cursor.com/docs/cookbook/large-codebases
---

# Large Codebase Patterns

Working with large codebases requires different strategies than smaller projects. Use these patterns to navigate complexity effectively.

## Navigation Strategies

### Use Chat for Quick Understanding

**Instead of manual exploration:**
- Ask questions: "How does X work?"
- Get detailed explanations with examples
- Understand unfamiliar code quickly

**Example:**
```
How does semantic search work in this codebase?
Show me examples of memory extraction
```

### Incremental Understanding

**Build understanding step by step:**
1. Start broad: "Give me high-level overview"
2. Narrow down: "How does authentication work?"
3. Get specific: "Show me token refresh flow"
4. Deep dive: "Why does this function check for null?"

**Each question builds on previous context**

## Codebase Exploration

### Start with Chat

**Ask natural questions:**
- "How does logging work in this project?"
- "How do I add a new API endpoint?"
- "What edge cases does CustomerOnboardingFlow handle?"
- "Walk me through what happens when user submits login form"

**Agent uses:**
- Semantic search for conceptual understanding
- Grep for exact matches
- Combines both for comprehensive results

### Building Understanding Incrementally

**Recommended flow:**
1. High-level overview
2. System-level understanding
3. Component-level details
4. Function-level specifics

**Example progression:**
1. "Overview of Omi architecture"
2. "How does the authentication system work?"
3. "Show me the token refresh flow"
4. "Why does this function check for null here?"

## Writing Rules for Domain Knowledge

### Document Patterns

**If onboarding a new collaborator, what would you tell them?**
- That information is valuable for Cursor too
- Write rules to encode domain knowledge

**Example rule:**
```
---
description: Add a new VS Code frontend service
---

1. Interface Definition: Use createDecorator, include _serviceBrand
2. Service Implementation: Extend Disposable, register as singleton
3. Service Contribution: Create contribution file, register in entrypoint
4. Context Integration: Update context to include new service
```

### Auto-Attach Rules with Globs

**Pattern-based rules:**
```
---
globs: *.ts
---

Use bun as package manager
Use kebab-case for file names
Use camelCase for functions
Prefer function foo() over const foo = () =>
```

## Plan Creation Process

### For Larger Changes

**Spend extra time on planning:**
- Create precise, well-scoped plan
- Like creating PRD for coworker
- Human figures out WHAT, AI implements HOW

### Using Ask Mode for Planning

**Turn on Ask mode and:**
- Dump context from project management
- Include known files/folders to reference
- Ask agent to create plan and ask questions

**Example prompt:**
```
Create a plan for new feature (like @existingfeature.ts)
Ask me questions (max 3) if unclear
Make sure to search the codebase
Context from [project management tool]: [ticket description]
```

**Recommended models for planning:**
- `claude-sonnet-4.5`
- `gpt-5-codex`
- `gemini-2.5-pro`

### Starting Over from Plan

**If implementation doesn't match plan:**
- Revert changes
- Refine plan to be more specific
- Run plan again (often faster than fixing)

## Tool Selection

### Right Tool for the Job

| Tool | Use Case | Strength | Limitation |
|------|----------|----------|------------|
| **Tab** | Quick, manual changes | Full control, fast | Single-file |
| **Inline Edit** | Scoped changes in one file | Focused edits | Single-file |
| **Chat** | Larger, multi-file changes | Auto-gathers context, deep edits | Slower, context-heavy |

### Chat Mode Best Practices

**Provide good context:**
- Use @files to point to similar code
- Use @folder to show project structure
- Break bigger changes into smaller chunks
- Start fresh chats to keep focused

## Codebase Understanding Workflow

### Onboarding to New Codebase

**Use Agent like knowledgeable teammate:**
- "How does logging work in this project?"
- "How do I add a new API endpoint?"
- "What edge cases does CustomerOnboardingFlow handle?"
- "Why are we calling setUser() instead of createUser()?"
- "Walk me through what happens when user submits login form"

**Agent uses:**
- Grep for exact matches
- Semantic search for conceptual understanding
- Fastest way to ramp up on unfamiliar code

### Building Understanding Incrementally

**Start broad, narrow down:**
1. "High-level overview of this codebase"
2. "How does the authentication system work?"
3. "Show me the token refresh flow specifically"
4. "Why does this function check for null here?"

**Each question builds on last**
**Agent maintains context throughout**

## Architecture Diagrams

### Generating Diagrams

**For significant changes or documentation:**
```
Create a Mermaid diagram showing the data flow for our authentication system,
including OAuth providers, session management, and token refresh.
```

**Agent analyzes codebase and generates diagram**

**Useful for:**
- PR descriptions explaining complex changes
- Documentation for new team members
- Revealing architectural issues before code review

## Omi-Specific Patterns

### Multi-Component Understanding

**Omi has multiple components:**
- Backend (Python/FastAPI)
- Flutter App (Dart)
- Firmware (C/C++)
- Web (Next.js)
- Plugins (Python/Node.js)

**Strategy:**
1. Understand one component at a time
2. Use @ mentions to reference related code
3. Build understanding incrementally
4. Use Plan Mode for cross-component features

### Large File Management

**Omi has large files:**
- ARB files (localization)
- Generated files
- Configuration files

**Strategy:**
- Use @ mentions for specific sections
- Let agent search for patterns
- Reference files instead of copying
- Use semantic search for understanding

## Context Window Management

### For Large Codebases

1. **Use semantic search**: More efficient than attaching files
2. **Reference files**: Point to files, don't copy content
3. **Break into chunks**: Multiple conversations for large tasks
4. **Use Plan Mode**: Create plans for complex features
5. **Start fresh chats**: Keep conversations focused

### Monitoring Context

- Check context gauge in chat
- Use `/summarize` when needed
- Start new chat for unrelated tasks
- Use @ mentions strategically

## Related Resources

### Rules
- `.cursor/rules/codebase-overview.mdc` - System architecture
- `.cursor/rules/context-management.mdc` - Context optimization
- `.cursor/rules/semantic-search.mdc` - Search strategies

### Commands
- `/plan` - Plan mode workflow
- `/semantic-search` - Search guidance

### Skills
- `.cursor/skills/context-optimization/` - Context management

### Documentation
- [Cursor Large Codebases Guide](https://cursor.com/docs/cookbook/large-codebases)