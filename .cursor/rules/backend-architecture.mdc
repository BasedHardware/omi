---
description: "Omi backend FastAPI architecture module hierarchy data flow patterns database utils routers main.py import rules"
globs:
  - "backend/**/*.py"
alwaysApply: false
---

# Backend Architecture

## System Overview

The Omi backend is a FastAPI application organized into clear layers with strict module hierarchy to prevent circular dependencies.

## Module Hierarchy

**Import Order (lowest to highest - NEVER reverse this)**:
1. `database/` - Database connections, cache instances, data access
2. `utils/` - Utility functions, business logic, helpers
3. `routers/` - API endpoints (FastAPI routers)
4. `main.py` - Application entry point

### Import Rules

```python
# ✅ GOOD - utils importing from database
# utils/apps.py
from database.cache import get_memory_cache
from database.redis_db import r

# ❌ BAD - utils importing from routers or main
# utils/apps.py
from main import memory_cache  # Don't import from higher level
from routers.apps import some_function  # Don't import from higher level

# ❌ BAD - database importing from utils or routers
# database/conversations.py
from utils.llm import extract_title  # Don't import from higher level
```

## Architecture Layers

### 1. Database Layer (`database/`)

**Purpose**: Data access and storage operations

**Key Modules**:
- `conversations.py` - Firestore conversation CRUD
- `memories.py` - Memory storage and retrieval
- `vector_db.py` - Pinecone vector operations
- `redis_db.py` - Redis caching
- `action_items.py` - Task management

**Patterns**:
- All database operations go through this layer
- Functions return data models, not raw database objects
- Handle errors gracefully (return None, raise exceptions appropriately)

### 2. Utils Layer (`utils/`)

**Purpose**: Business logic and utility functions

**Key Directories**:
- `llm/` - LLM client configurations and processing
- `retrieval/` - LangGraph agentic system and RAG
- `conversations/` - Conversation processing pipeline
- `stt/` - Speech-to-text utilities
- `other/` - Storage, webhooks, notifications

**Patterns**:
- Utils can import from database, but NOT from routers or main
- Business logic lives here, not in routers
- Functions should be pure when possible (no side effects)

### 3. Routers Layer (`routers/`)

**Purpose**: API endpoints (FastAPI routers)

**Key Routers**:
- `transcribe.py` - WebSocket audio streaming
- `conversations.py` - Conversation management
- `chat.py` - Chat system with LangGraph
- `memories.py` - Memory operations
- `developer.py` - Developer API

**Patterns**:
- Routers are thin - they validate input, call utils, return responses
- Use FastAPI dependency injection for auth, database access
- Keep router functions focused on HTTP concerns

### 4. Main Application (`main.py`)

**Purpose**: Application setup and configuration

**Responsibilities**:
- FastAPI app initialization
- Router registration
- Middleware setup
- Firebase initialization

## Data Flow Patterns

### Conversation Processing Flow

```
Audio → WebSocket (/v4/listen) → STT Service → Transcript
Transcript → process_conversation() → LLM Extraction → Firestore + Pinecone
```

### Chat Query Flow

```
Query → LangGraph Router → Tool Calls → Context Retrieval → LLM Response
```

### Storage Strategy

- **Firestore**: Primary database (conversations, memories, users)
- **Pinecone**: Vector embeddings for semantic search
- **Redis**: Caching (speech profiles, enabled apps, user names)
- **GCS**: Binary files (audio, photos, speech profiles)

## Key Design Principles

1. **Separation of Concerns**: Each layer has a clear responsibility
2. **Dependency Direction**: Always import downward in the hierarchy
3. **Error Handling**: Graceful degradation when optional services unavailable
4. **Caching Strategy**: Redis for metadata, GCS for binaries
5. **Real-time Processing**: WebSockets for bidirectional streaming

## Related Documentation

- Architecture: `.cursor/ARCHITECTURE.md`
- Backend Components: `.cursor/BACKEND_COMPONENTS.md`
- Backend Deep Dive: `docs/doc/developer/backend/backend_deepdive.mdx`
