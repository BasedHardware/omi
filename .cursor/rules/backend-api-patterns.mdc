---
description: "FastAPI router patterns endpoint conventions error handling authentication dependency injection Pydantic validation HTTPException"
globs:
  - "backend/routers/**/*.py"
alwaysApply: false
---

# Backend API Patterns

## FastAPI Router Structure

### Router Definition

```python
from fastapi import APIRouter, Depends, HTTPException
from typing import Optional

router = APIRouter(prefix="/v1", tags=["conversations"])

@router.post("/conversations")
async def create_conversation(
    uid: str = Depends(get_current_user),
    # ... other parameters
):
    """Create or finalize a conversation."""
    # Implementation
```

### Endpoint Patterns

#### Standard CRUD Endpoints

```python
@router.get("/resource")
async def list_resources(
    uid: str = Depends(get_current_user),
    limit: int = 25,
    offset: int = 0,
):
    """List resources with pagination."""
    items = await database.get_resources(uid, limit, offset)
    return {"items": items, "limit": limit, "offset": offset}

@router.get("/resource/{resource_id}")
async def get_resource(
    resource_id: str,
    uid: str = Depends(get_current_user),
):
    """Get a specific resource."""
    resource = await database.get_resource(uid, resource_id)
    if not resource:
        raise HTTPException(status_code=404, detail="Resource not found")
    return resource

@router.post("/resource")
async def create_resource(
    data: ResourceCreate,
    uid: str = Depends(get_current_user),
):
    """Create a new resource."""
    resource = await database.create_resource(uid, data)
    return resource

@router.put("/resource/{resource_id}")
async def update_resource(
    resource_id: str,
    data: ResourceUpdate,
    uid: str = Depends(get_current_user),
):
    """Update a resource."""
    resource = await database.update_resource(uid, resource_id, data)
    if not resource:
        raise HTTPException(status_code=404, detail="Resource not found")
    return resource

@router.delete("/resource/{resource_id}")
async def delete_resource(
    resource_id: str,
    uid: str = Depends(get_current_user),
):
    """Delete a resource."""
    success = await database.delete_resource(uid, resource_id)
    if not success:
        raise HTTPException(status_code=404, detail="Resource not found")
    return {"status": "deleted"}
```

## Authentication Patterns

### User Authentication

```python
from fastapi import Depends
from utils.auth import get_current_user

@router.get("/protected")
async def protected_endpoint(
    uid: str = Depends(get_current_user),
):
    """Endpoint requiring authentication."""
    # uid is the Firebase user ID
    pass
```

### API Key Authentication (Developer API)

```python
from utils.dev_api_keys import verify_dev_api_key

@router.get("/dev/user/memories")
async def get_memories_dev(
    api_key: str = Depends(verify_dev_api_key),
    uid: str = Depends(get_user_from_api_key),
):
    """Developer API endpoint."""
    pass
```

## Error Handling

### Standard Error Responses

```python
from fastapi import HTTPException

# 400 Bad Request
raise HTTPException(status_code=400, detail="Invalid parameters")

# 401 Unauthorized
raise HTTPException(status_code=401, detail="Authentication required")

# 403 Forbidden
raise HTTPException(status_code=403, detail="Insufficient permissions")

# 404 Not Found
raise HTTPException(status_code=404, detail="Resource not found")

# 422 Unprocessable Entity
raise HTTPException(status_code=422, detail="Validation error")

# 429 Too Many Requests
raise HTTPException(status_code=429, detail="Rate limit exceeded")
```

### Error Response Format

All errors return:
```json
{
  "detail": "Error message here"
}
```

## WebSocket Patterns

### WebSocket Endpoint

```python
from fastapi import WebSocket, WebSocketDisconnect

@router.websocket("/v4/listen")
async def websocket_endpoint(
    websocket: WebSocket,
    uid: str,
    language: Optional[str] = None,
):
    """WebSocket endpoint for real-time audio streaming."""
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_bytes()
            # Process audio data
            result = await process_audio(data)
            await websocket.send_json(result)
    except WebSocketDisconnect:
        # Handle disconnect
        pass
```

## Streaming Responses

### Server-Sent Events (SSE)

```python
from fastapi.responses import StreamingResponse
import asyncio

@router.get("/stream")
async def stream_endpoint():
    """Stream data via SSE."""
    async def generate():
        while True:
            data = await get_data()
            yield f"data: {json.dumps(data)}\n\n"
            await asyncio.sleep(1)
    
    return StreamingResponse(generate(), media_type="text/event-stream")
```

## Request Validation

### Pydantic Models

```python
from pydantic import BaseModel, Field

class ConversationCreate(BaseModel):
    title: Optional[str] = None
    transcript: str = Field(..., min_length=1)
    language: Optional[str] = "en"

@router.post("/conversations")
async def create_conversation(
    data: ConversationCreate,
    uid: str = Depends(get_current_user),
):
    """Create conversation with validated data."""
    # data is already validated
    pass
```

## Rate Limiting

### Rate Limit Decorator

```python
from utils.rate_limit import rate_limit

@router.get("/endpoint")
@rate_limit(requests=100, period=60)  # 100 requests per minute
async def rate_limited_endpoint():
    pass
```

## Response Models

### Response Types

```python
from typing import List
from models.conversation import Conversation

@router.get("/conversations", response_model=List[Conversation])
async def list_conversations():
    """Return list of conversations with proper typing."""
    pass
```

## Router Organization

### File Structure

- One router per file
- Group related endpoints
- Use tags for API documentation
- Prefix for versioning (`/v1`, `/v2`, etc.)

### Example Router File

```python
from fastapi import APIRouter, Depends, HTTPException
from typing import List, Optional

router = APIRouter(prefix="/v1", tags=["memories"])

@router.get("/memories")
async def list_memories(
    uid: str = Depends(get_current_user),
    limit: int = 25,
    offset: int = 0,
):
    """List user memories."""
    # Implementation
    pass

@router.post("/memories")
async def create_memory(
    data: MemoryCreate,
    uid: str = Depends(get_current_user),
):
    """Create a memory."""
    # Implementation
    pass
```

## Best Practices

1. **Keep routers thin**: Business logic in utils, not routers
2. **Use dependency injection**: For auth, database access, etc.
3. **Validate input**: Use Pydantic models
4. **Handle errors consistently**: Use HTTPException with appropriate status codes
5. **Document endpoints**: Use docstrings and response models
6. **Version APIs**: Use prefix for versioning
7. **Tag endpoints**: Group related endpoints with tags

## Related Documentation

- API Reference: `.cursor/API_REFERENCE.md`
- Backend Components: `.cursor/BACKEND_COMPONENTS.md`
- Backend Architecture: `.cursor/rules/backend-architecture.mdc`
