---
description: "Audio codec Opus PCM Mu-law encoding decoding 16kHz 8kHz sample rate bit depth little-endian packet structure"
globs:
  - "omi/**/*.c"
  - "omi/**/*.h"
  - "omiGlass/**/*.c"
  - "omiGlass/**/*.h"
alwaysApply: false
references:
  - docs/doc/developer/Protocol.mdx
---

# Firmware Audio Codecs

## Supported Codecs

### Codec Types

| Value | Codec | Sample Rate | Bit Depth | Channels |
|-------|-------|-------------|-----------|----------|
| `0` | PCM | 16 kHz | 16-bit | Mono |
| `1` | PCM | 8 kHz | 16-bit | Mono |
| `10` | Mu-law | 16 kHz | 8-bit | Mono |
| `11` | Mu-law | 8 kHz | 8-bit | Mono |
| `20` | Opus | 16 kHz | 16-bit | Mono |

**Default**: Opus (codec type 20) since firmware v1.0.3

## Opus Encoding

### Opus Encoder Setup

```c
#include <opus.h>

OpusEncoder *encoder;
opus_int16 pcm[160];  // 160 samples per frame
unsigned char opus_data[40];  // Opus output buffer

void init_opus_encoder() {
    int error;
    encoder = opus_encoder_create(
        16000,  // Sample rate: 16 kHz
        1,      // Channels: mono
        OPUS_APPLICATION_VOIP,  // Application type
        &error
    );
    
    if (error != OPUS_OK) {
        // Handle initialization error
    }
    
    // Set bitrate (optional)
    opus_encoder_ctl(encoder, OPUS_SET_BITRATE(16000));
}

void encode_audio_frame(opus_int16 *pcm_samples) {
    int encoded_bytes = opus_encode(
        encoder,
        pcm_samples,
        160,  // Frame size: 160 samples
        opus_data,
        40    // Output buffer size
    );
    
    if (encoded_bytes < 0) {
        // Handle encoding error
        return;
    }
    
    // Send opus_data via BLE
    send_audio_packet(opus_data, encoded_bytes);
}

void cleanup_opus_encoder() {
    if (encoder) {
        opus_encoder_destroy(encoder);
        encoder = NULL;
    }
}
```

### Opus Frame Structure

- **Frame size**: 160 samples (10ms at 16 kHz)
- **Bitrate**: Typically 16 kbps for voice
- **Application**: OPUS_APPLICATION_VOIP for real-time voice

## PCM Encoding

### PCM 16-bit Format

```c
// 16-bit PCM, little-endian
void send_pcm_audio(int16_t *samples, int count) {
    uint8_t buffer[count * 2];  // 2 bytes per sample
    
    for (int i = 0; i < count; i++) {
        // Little-endian byte order
        buffer[i * 2] = samples[i] & 0xFF;           // Low byte
        buffer[i * 2 + 1] = (samples[i] >> 8) & 0xFF; // High byte
    }
    
    // Send via BLE
    send_audio_packet(buffer, sizeof(buffer));
}
```

### PCM Sample Rates

- **16 kHz**: Higher quality, more bandwidth
- **8 kHz**: Lower quality, less bandwidth

## Mu-law Encoding

### Mu-law Compression

```c
// Mu-law encoding (8-bit compressed from 16-bit)
uint8_t mu_law_encode(int16_t sample) {
    // Get sign bit
    uint8_t sign = (sample >> 8) & 0x80;
    
    // Get magnitude
    if (sign) {
        sample = -sample;
    }
    
    // Clamp to 14-bit
    if (sample > 32635) {
        sample = 32635;
    }
    
    // Add bias
    sample += 33;
    
    // Find exponent
    uint8_t exponent = 7;
    for (int i = 0; i < 8; i++) {
        if (sample <= ((0x1F << (i + 1)) + 0x20)) {
            exponent = i;
            break;
        }
    }
    
    // Calculate mantissa
    uint8_t mantissa = (sample >> (exponent + 3)) & 0x0F;
    
    // Combine sign, exponent, mantissa
    return ~(sign | (exponent << 4) | mantissa);
}

void send_mulaw_audio(int16_t *samples, int count) {
    uint8_t buffer[count];
    
    for (int i = 0; i < count; i++) {
        buffer[i] = mu_law_encode(samples[i]);
    }
    
    // Send via BLE
    send_audio_packet(buffer, sizeof(buffer));
}
```

## Codec Selection

### Negotiating Codec Type

```c
static uint8_t current_codec_type = 20;  // Default: Opus

static ssize_t write_codec_type(struct bt_conn *conn,
                                const struct bt_gatt_attr *attr,
                                const void *buf, uint16_t len, uint16_t offset,
                                uint8_t flags) {
    if (len != 1) {
        return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    }
    
    uint8_t codec_type = ((uint8_t *)buf)[0];
    
    // Validate codec type
    if (codec_type != 0 && codec_type != 1 && 
        codec_type != 10 && codec_type != 11 && 
        codec_type != 20) {
        return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
    }
    
    // Switch codec
    current_codec_type = codec_type;
    
    // Reinitialize encoder if needed
    if (codec_type == 20) {
        init_opus_encoder();
    }
    
    return len;
}
```

## Audio Packet Format

### Packet Structure

All codecs use the same packet header format:

```c
typedef struct {
    uint16_t packet_number;  // Little-endian, 0-65535
    uint8_t index;           // Position within packet (for fragmentation)
    uint8_t audio_data[];    // Codec-specific audio data
} audio_packet_t;
```

### Packet Size

- **160 samples per packet** (10ms at 16 kHz, 20ms at 8 kHz)
- **PCM 16-bit**: 320 bytes per packet
- **PCM 8 kHz**: 320 bytes per packet
- **Mu-law**: 160 bytes per packet
- **Opus**: Variable (typically 20-40 bytes per packet)

## Best Practices

1. **Default to Opus**: Most efficient codec, use as default
2. **Frame Alignment**: Always encode 160 samples per frame
3. **Error Handling**: Check encoder return values
4. **Memory Management**: Free encoder resources on cleanup
5. **Bitrate Control**: Set appropriate bitrate for Opus
6. **Byte Order**: Always use little-endian for multi-byte values

## Related Documentation

- Firmware Architecture: `.cursor/rules/firmware-architecture.mdc`
- Firmware BLE Service: `.cursor/rules/firmware-ble-service.mdc`
- Protocol: `docs/doc/developer/Protocol.mdx`

## Related Cursor Resources

### Rules
- `.cursor/rules/firmware-architecture.mdc` - Firmware system architecture
- `.cursor/rules/firmware-ble-service.mdc` - BLE service for audio transmission
- `.cursor/rules/flutter-ble-protocol.mdc` - Flutter codec handling

### Skills
- `.cursor/skills/omi-firmware-patterns/` - Firmware patterns including codecs

### Subagents
- `.cursor/agents/firmware-engineer/` - Firmware codec specialist

### Commands
- `/flutter-setup` - Setup firmware development environment
