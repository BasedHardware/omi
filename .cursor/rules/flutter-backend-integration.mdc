---
description: "Flutter HTTP client REST API WebSocket real-time audio streaming authentication error handling retry logic Dio"
globs:
  - "app/lib/backend/**/*.dart"
alwaysApply: false
references:
  - docs/doc/developer/api/overview.mdx
  - .cursor/docs/API_REFERENCE.md
  - app/README.md
---

# Flutter Backend Integration

## API Client Architecture

### HTTP Client Setup

```dart
// lib/backend/http/shared.dart
class HttpClient {
  final Dio dio;
  final String baseUrl;
  
  HttpClient(this.baseUrl) : dio = Dio(BaseOptions(
    baseUrl: baseUrl,
    headers: {
      'Content-Type': 'application/json',
    },
  ));
  
  Future<Response> get(String path, {Map<String, dynamic>? queryParameters}) async {
    return await dio.get(path, queryParameters: queryParameters);
  }
  
  Future<Response> post(String path, {dynamic data}) async {
    return await dio.post(path, data: data);
  }
}
```

### API Endpoint Clients

```dart
// lib/backend/http/api/conversations.dart
class ConversationsAPI {
  final HttpClient httpClient;
  
  ConversationsAPI(this.httpClient);
  
  Future<List<Conversation>> getConversations({
    int limit = 25,
    int offset = 0,
    bool includeDiscarded = false,
  }) async {
    final response = await httpClient.get(
      '/v1/conversations',
      queryParameters: {
        'limit': limit,
        'offset': offset,
        'include_discarded': includeDiscarded,
      },
    );
    
    return (response.data['items'] as List)
        .map((json) => Conversation.fromJson(json))
        .toList();
  }
  
  Future<Conversation> getConversation(String id) async {
    final response = await httpClient.get('/v1/conversations/$id');
    return Conversation.fromJson(response.data);
  }
  
  Future<Conversation> createConversation() async {
    final response = await httpClient.post('/v1/conversations', data: {});
    return Conversation.fromJson(response.data);
  }
}
```

## WebSocket Communication

### WebSocket Client

```dart
// lib/backend/http/webhooks.dart
class WebSocketClient {
  WebSocket? _socket;
  final String baseUrl;
  final Function(Map<String, dynamic>) onTranscript;
  final Function(String) onError;
  
  WebSocketClient({
    required this.baseUrl,
    required this.onTranscript,
    required this.onError,
  });
  
  Future<void> connect(String uid, {String? language}) async {
    final uri = Uri.parse(
      '$baseUrl/v4/listen?uid=$uid${language != null ? '&language=$language' : ''}',
    );
    
    try {
      _socket = await WebSocket.connect(uri.toString());
      
      _socket!.listen(
        (data) {
          try {
            final json = jsonDecode(data);
            onTranscript(json);
          } catch (e) {
            onError('Failed to parse transcript: $e');
          }
        },
        onError: (error) {
          onError('WebSocket error: $error');
        },
        onDone: () {
          onError('WebSocket disconnected');
        },
      );
    } catch (e) {
      onError('Failed to connect: $e');
    }
  }
  
  void sendAudio(List<int> audioData) {
    _socket?.add(audioData);
  }
  
  void disconnect() {
    _socket?.close();
    _socket = null;
  }
}
```

### Using WebSocket in Provider

```dart
class CaptureProvider extends ChangeNotifier {
  WebSocketClient? _wsClient;
  List<TranscriptSegment> _segments = [];
  
  Future<void> startRecording() async {
    final uid = await getCurrentUserId();
    _wsClient = WebSocketClient(
      baseUrl: apiBaseUrl,
      onTranscript: (data) {
        _segments.add(TranscriptSegment.fromJson(data));
        notifyListeners();
      },
      onError: (error) {
        // Handle error
      },
    );
    
    await _wsClient!.connect(uid, language: 'en');
  }
  
  void stopRecording() {
    _wsClient?.disconnect();
    _wsClient = null;
  }
}
```

## Authentication

### Token Management

```dart
// Store auth token
await preferences.setString('auth_token', token);

// Include in requests
final token = await preferences.getString('auth_token');
httpClient.dio.options.headers['Authorization'] = 'Bearer $token';
```

### Firebase Auth Integration

```dart
import 'package:firebase_auth/firebase_auth.dart';

class AuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  Future<User?> signInWithGoogle() async {
    final GoogleSignInAccount? googleUser = await GoogleSignIn().signIn();
    if (googleUser == null) return null;
    
    final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
    final credential = GoogleAuthProvider.credential(
      accessToken: googleAuth.accessToken,
      idToken: googleAuth.idToken,
    );
    
    return (await _auth.signInWithCredential(credential)).user;
  }
  
  String? get currentUserId => _auth.currentUser?.uid;
}
```

## Error Handling

### API Error Handling

```dart
class APIException implements Exception {
  final int? statusCode;
  final String message;
  
  APIException(this.statusCode, this.message);
}

Future<T> handleAPIRequest<T>(Future<T> Function() request) async {
  try {
    return await request();
  } on DioException catch (e) {
    if (e.response != null) {
      throw APIException(
        e.response!.statusCode,
        e.response!.data['detail'] ?? 'API error',
      );
    }
    throw APIException(null, 'Network error: ${e.message}');
  } catch (e) {
    throw APIException(null, 'Unexpected error: $e');
  }
}
```

### Retry Logic

```dart
Future<T> retryRequest<T>(
  Future<T> Function() request, {
  int maxRetries = 3,
  Duration delay = const Duration(seconds: 1),
}) async {
  for (int i = 0; i < maxRetries; i++) {
    try {
      return await request();
    } catch (e) {
      if (i == maxRetries - 1) rethrow;
      await Future.delayed(delay * (i + 1));
    }
  }
  throw Exception('Max retries exceeded');
}
```

## Data Models

### JSON Serialization

```dart
class Conversation {
  final String id;
  final DateTime createdAt;
  final String? title;
  final List<TranscriptSegment> segments;
  
  Conversation({
    required this.id,
    required this.createdAt,
    this.title,
    required this.segments,
  });
  
  factory Conversation.fromJson(Map<String, dynamic> json) {
    return Conversation(
      id: json['id'],
      createdAt: DateTime.parse(json['created_at']),
      title: json['title'],
      segments: (json['transcript_segments'] as List?)
          ?.map((s) => TranscriptSegment.fromJson(s))
          .toList() ?? [],
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'created_at': createdAt.toIso8601String(),
      'title': title,
      'transcript_segments': segments.map((s) => s.toJson()).toList(),
    };
  }
}
```

## Best Practices

1. **Error Handling**: Always handle API errors gracefully
2. **Retry Logic**: Implement retry for transient failures
3. **Token Management**: Securely store and refresh auth tokens
4. **WebSocket Lifecycle**: Properly manage WebSocket connections
5. **Data Models**: Use consistent JSON serialization
6. **Loading States**: Show loading indicators during API calls
7. **Offline Support**: Handle offline scenarios gracefully

## Related Documentation

**The `docs/` folder is the single source of truth for all user-facing documentation, deployed at [docs.omi.me](https://docs.omi.me/).**

- **App Setup**: `docs/doc/developer/AppSetup.mdx` - [View online](https://docs.omi.me/doc/developer/AppSetup)
- **API Overview**: `docs/doc/developer/api/overview.mdx` - [View online](https://docs.omi.me/doc/developer/api/overview)
- **API Endpoints**: `docs/api-reference/` - [View online](https://docs.omi.me/api-reference/)
- **Flutter Architecture**: `.cursor/rules/flutter-architecture.mdc`

## Related Cursor Resources

### Rules
- `.cursor/rules/flutter-architecture.mdc` - App structure and state management
- `.cursor/rules/backend-api-patterns.mdc` - Backend API patterns
- `.cursor/rules/backend-architecture.mdc` - Backend system architecture

### Skills
- `.cursor/skills/omi-flutter-patterns/` - Flutter patterns including backend integration
- `.cursor/skills/omi-api-integration/` - API integration patterns

### Subagents
- `.cursor/agents/flutter-developer/` - Flutter development specialist

### Commands
- `/flutter-setup` - Setup Flutter and backend connection
- `/flutter-test` - Test backend integration
