---
description: "Flutter BLE Bluetooth Low Energy device communication audio streaming codec Opus PCM Mu-law packet fragmentation flutter_blue_plus"
globs:
  - "app/lib/utils/bluetooth/**/*.dart"
  - "app/lib/services/**/*ble*.dart"
alwaysApply: false
references:
  - docs/doc/developer/Protocol.mdx
  - app/README.md
---

# Flutter BLE Protocol

## BLE Device Communication

### Device Discovery

```dart
import 'package:flutter_blue_plus/flutter_blue_plus.dart' as ble;

// Scan for Omi devices
Future<List<ble.BluetoothDevice>> scanForOmiDevices() async {
  final devices = <ble.BluetoothDevice>[];
  
  await ble.FlutterBluePlus.startScan(
    timeout: const Duration(seconds: 4),
  );
  
  ble.FlutterBluePlus.scanResults.listen((results) {
    for (var result in results) {
      if (result.device.platformName == 'Omi') {
        devices.add(result.device);
      }
    }
  });
  
  await Future.delayed(const Duration(seconds: 4));
  await ble.FlutterBluePlus.stopScan();
  
  return devices;
}
```

### Device Connection

```dart
class BLEDeviceService {
  ble.BluetoothDevice? _device;
  ble.BluetoothCharacteristic? _audioCharacteristic;
  ble.BluetoothCharacteristic? _codecCharacteristic;
  
  Future<void> connect(ble.BluetoothDevice device) async {
    _device = device;
    await device.connect();
    
    // Discover services
    final services = await device.discoverServices();
    
    // Find audio service
    final audioService = services.firstWhere(
      (s) => s.uuid.toString() == '19B10000-E8F2-537E-4F6C-D104768A1214',
    );
    
    // Get characteristics
    _audioCharacteristic = audioService.characteristics.firstWhere(
      (c) => c.uuid.toString() == '19B10001-E8F2-537E-4F6C-D104768A1214',
    );
    
    _codecCharacteristic = audioService.characteristics.firstWhere(
      (c) => c.uuid.toString() == '19B10002-E8F2-537E-4F6C-D104768A1214',
    );
    
    // Read codec type
    final codecBytes = await _codecCharacteristic!.read();
    final codecType = codecBytes[0];
    
    // Set up audio notifications
    await _audioCharacteristic!.setNotifyValue(true);
    _audioCharacteristic!.value.listen(_handleAudioData);
  }
  
  void _handleAudioData(List<int> data) {
    // Parse audio packet
    final packetNumber = (data[0] | (data[1] << 8));
    final index = data[2];
    final audioData = data.sublist(3);
    
    // Decode based on codec type
    // Forward to backend via WebSocket
  }
}
```

## Audio Packet Format

### Packet Structure

```dart
class AudioPacket {
  final int packetNumber;
  final int index;
  final List<int> audioData;
  
  AudioPacket({
    required this.packetNumber,
    required this.index,
    required this.audioData,
  });
  
  factory AudioPacket.fromBytes(List<int> bytes) {
    // Header: 3 bytes
    final packetNumber = bytes[0] | (bytes[1] << 8);  // Little-endian
    final index = bytes[2];
    final audioData = bytes.sublist(3);
    
    return AudioPacket(
      packetNumber: packetNumber,
      index: index,
      audioData: audioData,
    );
  }
}
```

### Codec Types

```dart
enum AudioCodec {
  pcm16khz(0, sampleRate: 16000, bitDepth: 16),
  pcm8khz(1, sampleRate: 8000, bitDepth: 16),
  mulaw16khz(10, sampleRate: 16000, bitDepth: 8),
  mulaw8khz(11, sampleRate: 8000, bitDepth: 8),
  opus16khz(20, sampleRate: 16000, bitDepth: 16);
  
  final int value;
  final int sampleRate;
  final int bitDepth;
  
  const AudioCodec(this.value, {required this.sampleRate, required this.bitDepth});
  
  static AudioCodec? fromValue(int value) {
    return AudioCodec.values.firstWhereOrNull((c) => c.value == value);
  }
}
```

## Audio Decoding

### Opus Decoding

```dart
import 'package:opus_dart/opus_dart.dart';

class OpusDecoder {
  late OpusDecoderDart _decoder;
  
  Future<void> initialize() async {
    _decoder = OpusDecoderDart(
      sampleRate: 16000,
      channels: 1,
    );
  }
  
  List<int> decode(List<int> encodedData) {
    return _decoder.decode(encodedData);
  }
}
```

### PCM Handling

```dart
List<int> parsePCM16(List<int> bytes) {
  // PCM 16-bit little-endian
  final samples = <int>[];
  for (int i = 0; i < bytes.length; i += 2) {
    final sample = bytes[i] | (bytes[i + 1] << 8);
    // Handle signed 16-bit
    samples.add(sample > 32767 ? sample - 65536 : sample);
  }
  return samples;
}
```

## Battery Service

### Reading Battery Level

```dart
Future<int?> readBatteryLevel(ble.BluetoothDevice device) async {
  final services = await device.discoverServices();
  final batteryService = services.firstWhere(
    (s) => s.uuid.toString() == '0000180f-0000-1000-8000-00805f9b34fb',
  );
  
  final batteryCharacteristic = batteryService.characteristics.firstWhere(
    (c) => c.uuid.toString() == '00002a19-0000-1000-8000-00805f9b34fb',
  );
  
  final bytes = await batteryCharacteristic.read();
  return bytes[0];  // Battery percentage (0-100)
}
```

## Device Information Service

### Reading Device Info

```dart
Future<DeviceInfo> readDeviceInfo(ble.BluetoothDevice device) async {
  final services = await device.discoverServices();
  final deviceInfoService = services.firstWhere(
    (s) => s.uuid.toString() == '0000180a-0000-1000-8000-00805f9b34fb',
  );
  
  // Read manufacturer
  final manufacturerChar = deviceInfoService.characteristics.firstWhere(
    (c) => c.uuid.toString() == '00002a29-0000-1000-8000-00805f9b34fb',
  );
  final manufacturer = String.fromCharCodes(await manufacturerChar.read());
  
  // Read firmware version
  final firmwareChar = deviceInfoService.characteristics.firstWhere(
    (c) => c.uuid.toString() == '00002a26-0000-1000-8000-00805f9b34fb',
  );
  final firmwareVersion = String.fromCharCodes(await firmwareChar.read());
  
  return DeviceInfo(
    manufacturer: manufacturer,
    firmwareVersion: firmwareVersion,
  );
}
```

## Best Practices

1. **Connection Management**: Always disconnect when done
2. **Error Handling**: Handle BLE errors gracefully
3. **Packet Reassembly**: Handle fragmented packets correctly
4. **Codec Support**: Support all codec types (Opus preferred)
5. **Battery Monitoring**: Monitor battery level and notify user
6. **Reconnection**: Implement automatic reconnection logic
7. **Platform Differences**: Handle iOS/Android BLE differences

## Related Documentation

**The `docs/` folder is the single source of truth for all user-facing documentation, deployed at [docs.omi.me](https://docs.omi.me/).**

- **BLE Protocol**: `docs/doc/developer/Protocol.mdx` - [View online](https://docs.omi.me/doc/developer/Protocol)
- **App Setup**: `docs/doc/developer/AppSetup.mdx` - [View online](https://docs.omi.me/doc/developer/AppSetup)
- **Firmware Compilation**: `docs/doc/developer/firmware/Compile_firmware.mdx` - [View online](https://docs.omi.me/doc/developer/firmware/Compile_firmware)
- **Hardware Docs**: `docs/doc/hardware/` - [View online](https://docs.omi.me/doc/hardware/)

## Related Cursor Resources

### Rules
- `.cursor/rules/flutter-architecture.mdc` - App structure
- `.cursor/rules/firmware-ble-service.mdc` - Firmware BLE implementation
- `.cursor/rules/firmware-audio-codecs.mdc` - Audio codec patterns

### Skills
- `.cursor/skills/omi-flutter-patterns/` - Flutter patterns including BLE
- `.cursor/skills/omi-firmware-patterns/` - Firmware patterns

### Subagents
- `.cursor/agents/flutter-developer/` - Flutter BLE integration specialist
- `.cursor/agents/firmware-engineer/` - Firmware BLE service specialist

### Commands
- `/flutter-setup` - Setup Flutter BLE dependencies
- `/flutter-test` - Test BLE functionality
