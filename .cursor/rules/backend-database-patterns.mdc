---
description: "Firestore Pinecone Redis GCS database patterns storage operations vector search caching metadata binary files"
globs:
  - "backend/database/**/*.py"
alwaysApply: false
references:
  - docs/doc/developer/backend/StoringConversations.mdx
  - docs/doc/developer/backend/backend_deepdive.mdx
  - backend/README.md
---

# Backend Database Patterns

## Storage Architecture

Omi uses a multi-database architecture:
- **Firestore**: Primary database (conversations, memories, users)
- **Pinecone**: Vector embeddings for semantic search
- **Redis**: Caching and metadata (optional but recommended)
- **GCS**: Binary files (audio, photos, speech profiles)

## Firestore Patterns

### Collection Structure

```
users/
├── {uid}/
│   ├── conversations/
│   │   └── {conversation_id}/
│   │       ├── id
│   │       ├── created_at
│   │       ├── structured (title, overview, action_items, events)
│   │       ├── transcript_segments[]
│   │       └── photos/ (subcollection)
│   ├── memories/
│   │   └── {memory_id}/
│   ├── action_items/
│   │   └── {action_item_id}/
│   └── ...
```

### Firestore Operations

#### Create/Update

```python
from database.conversations import upsert_conversation
from models.conversation import Conversation

async def create_conversation(uid: str, data: dict) -> Conversation:
    """Create or update a conversation."""
    conversation = Conversation(
        id=data.get("id") or generate_id(),
        user_id=uid,
        created_at=datetime.utcnow(),
        **data
    )
    await upsert_conversation(uid, conversation)
    return conversation
```

#### Read

```python
from database.conversations import get_conversation, get_conversations

# Get single conversation
conversation = await get_conversation(uid, conversation_id)

# List conversations with filters
conversations = await get_conversations(
    uid=uid,
    limit=25,
    include_discarded=False,
    start_date=start_date,
    end_date=end_date,
)
```

#### Delete (Soft Delete)

```python
from database.conversations import delete_conversation

# Soft delete (sets deleted=True)
await delete_conversation(uid, conversation_id)
```

### Firestore Best Practices

1. **Use subcollections**: For related data (e.g., photos in conversations)
2. **Index fields**: Add composite indexes for complex queries
3. **Batch operations**: Use batch writes for multiple operations
4. **Pagination**: Use `limit` and `start_after` for pagination
5. **Error handling**: Handle Firestore exceptions gracefully

## Pinecone Patterns

### Vector Operations

#### Upsert Embeddings

```python
from database.vector_db import upsert_vector
import numpy as np

# Generate embedding
embedding = await generate_embedding(text)

# Store in Pinecone
await upsert_vector(
    index_name="conversations",
    vector_id=conversation_id,
    embedding=embedding,
    metadata={
        "user_id": uid,
        "created_at": timestamp,
        "title": title,
    }
)
```

#### Query Similar Vectors

```python
from database.vector_db import query_vectors

# Generate query embedding
query_embedding = await generate_embedding(user_query)

# Search
results = await query_vectors(
    index_name="conversations",
    query_vector=query_embedding,
    top_k=5,
    filter={"user_id": uid},
)

# Results contain conversation IDs and similarity scores
for result in results:
    conversation_id = result.id
    similarity = result.score
```

### Pinecone Best Practices

1. **Namespace per user**: Use user ID as namespace for isolation
2. **Metadata filtering**: Use metadata for efficient filtering
3. **Batch operations**: Use `upsert_vectors` for multiple embeddings
4. **Top K selection**: Choose appropriate K (typically 5-10)
5. **Similarity threshold**: Filter by minimum similarity score

## Redis Patterns

### Caching Strategy

Redis is used for frequently accessed metadata, not primary data storage.

#### Cache Speech Profile Duration

```python
from database.redis_db import set_speech_profile_duration, get_speech_profile_duration

# Store duration (audio file in GCS)
await set_speech_profile_duration(uid, duration_seconds)

# Retrieve duration
duration = await get_speech_profile_duration(uid)
if duration:
    # Use cached duration
    pass
else:
    # Load from GCS and cache
    pass
```

#### Cache Enabled Apps

```python
from database.redis_db import enable_app, get_enabled_apps

# Enable app for user
await enable_app(uid, app_id)

# Get enabled apps
enabled_apps = await get_enabled_apps(uid)
```

#### Cache User Names

```python
from database.redis_db import cache_user_name, get_cached_user_name

# Cache user name
await cache_user_name(uid, name)

# Get cached name (fallback to Firestore if not cached)
name = await get_cached_user_name(uid)
if not name:
    # Fetch from Firestore and cache
    pass
```

### Redis Best Practices

1. **Cache metadata only**: Binary files go to GCS
2. **Set TTL**: Use expiration for cache entries
3. **Graceful degradation**: Handle Redis unavailability
4. **Key naming**: Use consistent key patterns (`user:{uid}:apps`)
5. **Pipeline operations**: Use pipelines for multiple operations

## Google Cloud Storage Patterns

### Upload Files

```python
from utils.other.storage import upload_profile_audio

# Upload speech profile
url = await upload_profile_audio(
    file_path="/path/to/audio.wav",
    uid=uid,
)
```

### Retrieve Files

```python
from utils.other.storage import get_profile_audio_if_exists

# Get speech profile if exists
audio_path = await get_profile_audio_if_exists(uid)
if audio_path:
    # Use audio file
    pass
```

### GCS Best Practices

1. **Bucket organization**: Use user ID in path structure
2. **Public URLs**: Generate signed URLs for access
3. **File cleanup**: Clean up temporary files after processing
4. **Error handling**: Handle GCS exceptions gracefully

## Transaction Patterns

### Firestore Transactions

```python
from google.cloud.firestore import Transaction

async def update_with_transaction(uid: str, conversation_id: str):
    """Update conversation atomically."""
    transaction = firestore_client.transaction()
    
    @firestore.transactional
    def update_in_transaction(transaction):
        conversation_ref = firestore_client.collection(
            f"users/{uid}/conversations"
        ).document(conversation_id)
        
        conversation = conversation_ref.get(transaction=transaction)
        # Update conversation
        transaction.update(conversation_ref, {"status": "completed"})
    
    update_in_transaction(transaction)
```

## Error Handling

### Database Errors

```python
from google.cloud.exceptions import NotFound
from pinecone.exceptions import PineconeException

try:
    conversation = await get_conversation(uid, conversation_id)
except NotFound:
    raise HTTPException(status_code=404, detail="Conversation not found")
except Exception as e:
    logger.error(f"Database error: {e}")
    raise HTTPException(status_code=500, detail="Database error")
```

## Performance Optimization

1. **Batch reads**: Use `get_all()` for multiple documents
2. **Index optimization**: Create composite indexes for queries
3. **Pagination**: Always paginate large result sets
4. **Caching**: Use Redis for frequently accessed data
5. **Vector search**: Use Pinecone for semantic search, not Firestore

## Related Documentation

**The `docs/` folder is the single source of truth for all user-facing documentation, deployed at [docs.omi.me](https://docs.omi.me/).**

- **Storing Conversations**: `docs/doc/developer/backend/StoringConversations.mdx` - [View online](https://docs.omi.me/doc/developer/backend/StoringConversations)
- **Backend Deep Dive**: `docs/doc/developer/backend/backend_deepdive.mdx` - [View online](https://docs.omi.me/doc/developer/backend/backend_deepdive)
- **Backend Architecture**: `.cursor/rules/backend-architecture.mdc`

## Related Cursor Resources

### Rules
- `.cursor/rules/backend-architecture.mdc` - System architecture and module hierarchy
- `.cursor/rules/backend-api-patterns.mdc` - API endpoint patterns
- `.cursor/rules/backend-llm-patterns.mdc` - LLM patterns for memory extraction
- `.cursor/rules/backend-imports.mdc` - Import rules for database modules

### Skills
- `.cursor/skills/omi-backend-patterns/` - Backend patterns including database operations

### Subagents
- `.cursor/agents/backend-database-engineer/` - Database optimization specialist

### Commands
- `/backend-setup` - Setup database connections
- `/backend-test` - Test database operations
