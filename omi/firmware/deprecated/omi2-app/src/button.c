/**
 * @file button.c
 * @brief Implementation of button handling functionality and BLE services
 * 
 * This file implements button event detection, processing, and notification via BLE.
 * It provides services to detect single taps, double taps, and long presses,
 * and notifies connected BLE clients of these events.
 */

#include <zephyr/kernel.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/gatt.h>
#include <zephyr/bluetooth/l2cap.h>
#include <zephyr/bluetooth/services/bas.h>
#include <zephyr/logging/log.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/poweroff.h>
#include <zephyr/input/input.h>
#include "button.h"
#include "transport.h"
#include "led.h"
#include "mic.h"
#include "sdcard.h"
#include "haptic.h"
LOG_MODULE_REGISTER(button, CONFIG_LOG_DEFAULT_LEVEL);

/* Global flag to track device power state */
bool is_off = false;

/* Function prototypes for BLE GATT service callbacks */
static void button_ccc_config_changed_handler(const struct bt_gatt_attr *attr, uint16_t value);
static ssize_t button_data_read_characteristic(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset);

/* BLE UUIDs for the button service and its characteristic */
static struct bt_uuid_128 button_uuid = BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x23BA7924,0x0000,0x1000,0x7450,0x346EAC492E92));
static struct bt_uuid_128 button_characteristic_data_uuid = BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x23BA7925 ,0x0000,0x1000,0x7450,0x346EAC492E92));

/* BLE GATT attributes for the button service */
static struct bt_gatt_attr button_service_attr[] = {
    BT_GATT_PRIMARY_SERVICE(&button_uuid),
    BT_GATT_CHARACTERISTIC(&button_characteristic_data_uuid.uuid, BT_GATT_CHRC_READ | BT_GATT_CHRC_NOTIFY, BT_GATT_PERM_READ, button_data_read_characteristic, NULL, NULL),
    BT_GATT_CCC(button_ccc_config_changed_handler, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
};

/* BLE GATT service definition */
static struct bt_gatt_service button_service = BT_GATT_SERVICE(button_service_attr);

/**
 * @brief Callback for Client Characteristic Configuration changes
 * 
 * Called when a connected client subscribes to or unsubscribes from notifications
 * 
 * @param attr GATT attribute
 * @param value CCC value (BT_GATT_CCC_NOTIFY for subscribed, 0 for unsubscribed)
 */
static void button_ccc_config_changed_handler(const struct bt_gatt_attr *attr, uint16_t value) 
{
    if (value == BT_GATT_CCC_NOTIFY)
    {
        LOG_INF("Client subscribed for notifications");
    }
    else if (value == 0)
    {
        LOG_INF("Client unsubscribed from notifications");
    }
    else
    {
        LOG_ERR("Invalid CCC value: %u", value);
    }
}

/* Button device from device tree */
static const struct device *const button_dev = DEVICE_DT_GET(DT_ALIAS(buttons));

/* Flag to track button press state */
static bool was_pressed = false;

/* Message queue for button events */
K_MSGQ_DEFINE(button_msgq, sizeof(struct input_event), 10, 4);

/**
 * @brief Input subsystem callback for button events
 * 
 * This function is called when button events are generated by the input subsystem.
 * It updates the was_pressed flag based on the button state and adds events to the queue.
 * 
 * @param evt Input event
 * @param user_data User data pointer (unused)
 */
static void button_input_cb(struct input_event *evt, void *user_data)
{
    ARG_UNUSED(user_data);
    
    if (evt->type == INPUT_EV_KEY && evt->code == INPUT_KEY_ENTER) {
        was_pressed = (evt->value == 1);
        LOG_PRINTK("button_input_cb %d\n", was_pressed);
        
        /* Put the event in the message queue for processing */
        k_msgq_put(&button_msgq, evt, K_NO_WAIT);
    }
}

/* Register the button callback with the input subsystem */
INPUT_CALLBACK_DEFINE(button_dev, button_input_cb, NULL);

/* Button polling interval in milliseconds (25Hz) */
#define BUTTON_CHECK_INTERVAL 40 // 0.04 seconds, 25 Hz

/* Forward declaration for the button checking work function */
void check_button_level(struct k_work *work_item);

/* Define a delayed work queue item for button polling */
K_WORK_DELAYABLE_DEFINE(button_work, check_button_level);

/* Button state machine states */
#define DEFAULT_STATE 0
#define SINGLE_TAP 1
#define DOUBLE_TAP 2
#define LONG_TAP 3
#define BUTTON_PRESS 4
#define BUTTON_RELEASE 5

/* Current state in the button state machine */
static FSM_STATE_T current_button_state = IDLE;
static uint32_t inc_count_1 = 0;
static uint32_t inc_count_0 = 0;

/* Array to store current button state for BLE notifications */
static int final_button_state[2] = {0,0};
const static int threshold = 10;

/**
 * @brief Reset the button press/release counters
 */
static void reset_count() 
{
    inc_count_0 = 0;
    inc_count_1 = 0;
}

/**
 * @brief Notify connected clients about button press event
 */
static inline void notify_press() 
{
    final_button_state[0] = BUTTON_PRESS;
    LOG_INF("Button pressed");
    struct bt_conn *conn = get_current_connection();
    if (conn != NULL)
    { 
        bt_gatt_notify(conn, &button_service.attrs[1], &final_button_state, sizeof(final_button_state));
    }
}

/**
 * @brief Notify connected clients about button release event
 */
static inline void notify_unpress() 
{
    final_button_state[0] = BUTTON_RELEASE; 
    LOG_INF("Button released");
    struct bt_conn *conn = get_current_connection();
    if (conn != NULL)
    { 
        bt_gatt_notify(conn, &button_service.attrs[1], &final_button_state, sizeof(final_button_state));
    }
}

/**
 * @brief Notify connected clients about single tap event
 */
static inline void notify_tap() 
{
    final_button_state[0] = SINGLE_TAP;
    LOG_INF("Button single tap");
    struct bt_conn *conn = get_current_connection();
    if (conn != NULL)
    { 
        bt_gatt_notify(conn, &button_service.attrs[1], &final_button_state, sizeof(final_button_state));
    }
}

/**
 * @brief Notify connected clients about double tap event
 */
static inline void notify_double_tap() 
{
    final_button_state[0] = DOUBLE_TAP; //button press
    LOG_INF("Button double tap");
    struct bt_conn *conn = get_current_connection();
    if (conn != NULL)
    { 
        bt_gatt_notify(conn, &button_service.attrs[1], &final_button_state, sizeof(final_button_state));
    }
}

/**
 * @brief Notify connected clients about long tap event
 */
static inline void notify_long_tap() 
{
    final_button_state[0] = LONG_TAP; //button press
    LOG_INF("Button long tap");
    struct bt_conn *conn = get_current_connection();
    if (conn != NULL)
    { 
        bt_gatt_notify(conn, &button_service.attrs[1], &final_button_state, sizeof(final_button_state));
    }
}

/* Button state constants */
#define BUTTON_PRESSED     1
#define BUTTON_RELEASED    0

/* Button event detection timing thresholds (in milliseconds) */
#define TAP_THRESHOLD      300  // 300 ms for single tap
#define DOUBLE_TAP_WINDOW  600  // 600 ms maximum for double-tap
#define LONG_PRESS_TIME    1000 // 1000 ms for long press

/* Button event types */
typedef enum {
    BUTTON_EVENT_NONE,
    BUTTON_EVENT_SINGLE_TAP,
    BUTTON_EVENT_DOUBLE_TAP,
    BUTTON_EVENT_LONG_PRESS,
    BUTTON_EVENT_RELEASE
} ButtonEvent;

/* Button state tracking variables */
static uint32_t current_time = 0;
static uint32_t btn_press_start_time;
static uint32_t btn_release_time;
static uint32_t btn_last_tap_time;
static bool btn_is_pressed;

static u_int8_t btn_last_event = BUTTON_EVENT_NONE;

/**
 * @brief Periodic function to check button state and detect events
 * 
 * This function implements the button event detection logic. It detects:
 * - Single taps: Short press and release
 * - Double taps: Two quick presses within DOUBLE_TAP_WINDOW
 * - Long presses: Held for longer than LONG_PRESS_TIME
 * 
 * It also handles putting the device to sleep on single tap.
 * 
 * @param work_item The work queue item
 */
void check_button_level(struct k_work *work_item) 
{
    current_time = current_time + 1;

    u_int8_t btn_state = was_pressed ? BUTTON_PRESSED : BUTTON_RELEASED;

    ButtonEvent event = BUTTON_EVENT_NONE;

    // Debouncing pressed state
    if (btn_state == BUTTON_PRESSED && !btn_is_pressed) {
        btn_is_pressed = true;
        btn_press_start_time = current_time;
    } else if (btn_state == BUTTON_RELEASED && btn_is_pressed) {
        btn_is_pressed = false;
        btn_release_time = current_time;

        // Check for double tap
        uint32_t press_duration = (btn_release_time - btn_press_start_time)*BUTTON_CHECK_INTERVAL;
        if (press_duration < TAP_THRESHOLD) {
            if (btn_last_tap_time > 0 && (current_time - btn_last_tap_time)*BUTTON_CHECK_INTERVAL < DOUBLE_TAP_WINDOW) {
                event = BUTTON_EVENT_DOUBLE_TAP;
                btn_last_tap_time = 0; // Reset double-tap / single-tap detection
            } else {
                btn_last_tap_time = current_time;
            }
        }
    } 

    // Check for single tap
    if (btn_state == BUTTON_RELEASED && !btn_is_pressed) {
        uint32_t press_duration = (btn_release_time - btn_press_start_time)*BUTTON_CHECK_INTERVAL;
        if (press_duration < TAP_THRESHOLD && btn_last_tap_time > 0 && (current_time - btn_press_start_time)*BUTTON_CHECK_INTERVAL > TAP_THRESHOLD) {
            event = BUTTON_EVENT_SINGLE_TAP;
            btn_last_tap_time = 0;
        } else if ((current_time - btn_press_start_time)*BUTTON_CHECK_INTERVAL > TAP_THRESHOLD) {
            event = BUTTON_EVENT_RELEASE;
        }
    }

    // Check for long press
    if (btn_is_pressed && (current_time - btn_press_start_time)*BUTTON_CHECK_INTERVAL >= LONG_PRESS_TIME) {
        event = BUTTON_EVENT_LONG_PRESS;
    }

    // Single tap
    if (event == BUTTON_EVENT_SINGLE_TAP)
    {
        LOG_PRINTK("single tap detected\n");
        btn_last_event = event;
        notify_tap();

		set_led_blue(true);
		k_msleep(50);
		set_led_blue(false);
		k_msleep(50);
		set_led_blue(true);
		k_msleep(50);
		set_led_blue(false);
		k_msleep(50);
		set_led_blue(true);
		k_msleep(50);
		set_led_blue(false);

        // Enter the low power mode
        // is_off = true;
        // bt_off();
		// TODO: uncomment this
        // turnoff_all(); 
    }

    // Double tap
    if (event == BUTTON_EVENT_DOUBLE_TAP)
    {
        LOG_PRINTK("double tap detected\n");
        btn_last_event = event;
        notify_double_tap();
    }

    // Long press, one time event
    if (event == BUTTON_EVENT_LONG_PRESS && btn_last_event != BUTTON_EVENT_LONG_PRESS)
    {
        LOG_PRINTK("long press detected\n");
        btn_last_event = event;
        notify_long_tap();
    }

    // Releases, one time event
    if (event == BUTTON_EVENT_RELEASE && btn_last_event != BUTTON_EVENT_RELEASE)
    {
        LOG_PRINTK("release detected\n");
        btn_last_event = event;
        notify_unpress();

        // Reset
        current_time = 0;
        btn_press_start_time = 0;
        btn_release_time = 0;
        btn_last_tap_time = 0;
    }
    if (event == BUTTON_EVENT_RELEASE)
    {
        current_button_state = GRACE;
    }

    k_work_reschedule(&button_work, K_MSEC(BUTTON_CHECK_INTERVAL));
    return 0;
}

/**
 * @brief GATT read callback for button data characteristic
 * 
 * This function handles read requests from connected clients for the button state.
 * 
 * @param conn BLE connection
 * @param attr GATT attribute
 * @param buf Buffer to write data to
 * @param len Maximum length of data to write
 * @param offset Offset to start writing from
 * @return Number of bytes written
 */
static ssize_t button_data_read_characteristic(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf, uint16_t len, uint16_t offset) 
{
    LOG_INF("button_data_read_characteristic");
    LOG_PRINTK("was_pressed: %d\n", final_button_state[0]);
    return bt_gatt_attr_read(conn, attr, buf, len, offset, &final_button_state, sizeof(final_button_state));
}

/**
 * @brief Initialize button hardware
 * 
 * This function sets up the button input device and initializes resources.
 * 
 * @return 0 on success, negative error code on failure
 */
int button_init() 
{
    if (!device_is_ready(button_dev)) {
        LOG_ERR("Button device not ready");
        return -ENODEV;
    }

    LOG_INF("Button device initialized successfully");
    
    /* Initialize the message queue */
    k_msgq_purge(&button_msgq);
    
    return 0;
}

/**
 * @brief Start the button monitoring work queue
 * 
 * This function starts the periodic button checking process.
 */
void activate_button_work() 
{
	LOG_INF("Activating button work");
    k_work_schedule(&button_work, K_MSEC(BUTTON_CHECK_INTERVAL));
}

/**
 * @brief Register the button BLE GATT service
 * 
 * This function makes the button service available to connected clients.
 */
void register_button_service() 
{
    bt_gatt_service_register(&button_service);
}

/**
 * @brief Get the current button state machine state
 * 
 * @return Current button state
 */
FSM_STATE_T get_current_button_state() 
{
    return current_button_state;
}

/**
 * @brief Power down all peripherals and enter system off mode
 * 
 * This function is called when the device needs to enter low power mode.
 * It disables all peripherals and puts the system into SYSTEMOFF state.
 */
void turnoff_all()
{
    /* Turn off all peripherals */
    mic_off();
    sd_off();
    imu_off();
    play_haptic_milli(50);
    k_msleep(100);
    set_led_blue(false);
    set_led_red(false);
    set_led_green(false);

    /* Put the device into system off mode */
    sys_poweroff();
}

/**
 * @brief Force the button state machine to a specific state
 * 
 * @param state The state to force the button state machine to
 */
void force_button_state(FSM_STATE_T state)
{
    current_button_state = state;
}
